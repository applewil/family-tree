{"version":3,"file":"main.js","mappings":";;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,mBAAmB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iBAAiB,8BAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,8CAA8C,IAAI;AAClD,kBAAkB,KAAK,EAAE,OAAO;AAChC,KAAK;AACL;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,EAAE,WAAW;AAClD;AACA;AACA,kBAAkB;;;;;;;AC3DL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,mBAAmB,GAAG,eAAe,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,gBAAgB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;UCrFA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ,qBAAqB,mBAAO,CAAC,CAAc;AAC3C,eAAe,mBAAO,CAAC,CAAQ;AAC/B;AACA;AACA;AACA,uCAAuC,YAAY;AACnD,wBAAwB,eAAe,GAAG,KAAK,WAAW,0BAA0B;AACpF;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA","sources":["webpack:///./src/encryption.ts","webpack:///./src/tree.ts","webpack:///webpack/bootstrap","webpack:///./src/main.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hexToBytes = exports.bytesToHex = exports.decryptData = exports.encryptData = void 0;\nconst ENCODER = new TextEncoder();\nconst DECODER = new TextDecoder();\nfunction getPasswordKey(password) {\n    return crypto.subtle.importKey('raw', ENCODER.encode(password), 'PBKDF2', false, ['deriveKey']);\n}\nfunction deriveKey(passwordKey, salt) {\n    return crypto.subtle.deriveKey({\n        name: 'PBKDF2',\n        salt: salt,\n        iterations: 1,\n        hash: 'SHA-256',\n    }, passwordKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);\n}\nasync function encryptData(data, password) {\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(16));\n    const passwordKey = await getPasswordKey(password);\n    const aesKey = await deriveKey(passwordKey, salt);\n    const encryptedContent = await crypto.subtle.encrypt({\n        name: 'AES-GCM',\n        iv: iv,\n    }, aesKey, ENCODER.encode(data));\n    let bytes = new Uint8Array([...salt, ...iv, ...new Uint8Array(encryptedContent)]);\n    return bytesToHex(bytes);\n}\nexports.encryptData = encryptData;\nasync function decryptData(data, password) {\n    const bytes = hexToBytes(data);\n    const salt = bytes.slice(0, 16);\n    const iv = bytes.slice(16, 16 + 16);\n    const encryptedData = bytes.slice(16 + 16);\n    const passwordKey = await getPasswordKey(password);\n    const aesKey = await deriveKey(passwordKey, salt);\n    const decryptedBytes = await crypto.subtle.decrypt({\n        name: 'AES-GCM',\n        iv: iv,\n    }, aesKey, encryptedData);\n    return DECODER.decode(decryptedBytes);\n}\nexports.decryptData = decryptData;\nfunction bytesToHex(buffer) {\n    return buffer.reduce((data, byte) => {\n        const hex = byte.toString(16);\n        const padded = hex.length === 1 ? `0${hex}` : hex;\n        return `${data}${padded}`;\n    }, '');\n}\nexports.bytesToHex = bytesToHex;\nfunction hexToBytes(hex) {\n    const bytes = Array(hex.length)\n        .fill(0)\n        .map((_, i) => i)\n        .filter(i => i % 2 === 0)\n        .map(i => parseInt(`${hex[i]}${hex[i + 1]}`, 16));\n    return new Uint8Array(bytes);\n}\nexports.hexToBytes = hexToBytes;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.importTree = exports.getChildren = exports.getNode = exports.getParents = exports.getLevel = exports.getDepth = void 0;\nfunction getDepth(root) {\n    if (root === undefined) {\n        return 0;\n    }\n    const fatherDepth = getDepth(root.father);\n    const motherDepth = getDepth(root.mother);\n    return Math.max(fatherDepth, motherDepth) + 1;\n}\nexports.getDepth = getDepth;\nfunction getLevel(root, level) {\n    if (root === undefined) {\n        return [];\n    }\n    if (level === 0) {\n        return [root];\n    }\n    return [...getLevel(root.father, level - 1), ...getLevel(root.mother, level - 1)];\n}\nexports.getLevel = getLevel;\nfunction getParents(root) {\n    if (root === undefined) {\n        return [];\n    }\n    const father = root.father ? [root.father, ...getParents(root.father)] : [];\n    const mother = root.mother ? [root.mother, ...getParents(root.mother)] : [];\n    return [...father, ...mother];\n}\nexports.getParents = getParents;\nfunction getNode(root, name) {\n    if (root === undefined) {\n        return undefined;\n    }\n    if (root.name === name) {\n        return root;\n    }\n    return getNode(root.father, name) || getNode(root.mother, name);\n}\nexports.getNode = getNode;\nfunction getChildren(root, subject, accumulator = []) {\n    if (root === undefined) {\n        return [];\n    }\n    if ([root.father, root.mother].includes(subject)) {\n        return [root, ...accumulator];\n    }\n    return [\n        ...getChildren(root.father, subject, [root, ...accumulator]),\n        ...getChildren(root.mother, subject, [root, ...accumulator]),\n    ];\n}\nexports.getChildren = getChildren;\nfunction importTree(people) {\n    const nameToPerson = new Map(people.map(person => [person.name, person]));\n    if (people.length !== nameToPerson.size) {\n        throw Error('Duplicate');\n    }\n    const parents = new Set([...people.flatMap(({ father, mother }) => [father, mother])]);\n    const roots = people.filter(({ name }) => !parents.has(name));\n    const [root, ...extra] = roots;\n    if (!root) {\n        throw Error('No root');\n    }\n    if (extra.length) {\n        throw Error('Multiple roots');\n    }\n    return convertPerson(root, nameToPerson);\n}\nexports.importTree = importTree;\nfunction convertPerson(root, nameToPerson) {\n    const parentCount = [root.father, root.mother].filter(parent => parent).length;\n    if (parentCount === 1) {\n        throw Error('Single parent');\n    }\n    if (parentCount === 0) {\n        return { ...root, father: undefined, mother: undefined };\n    }\n    if ([root.father, root.mother].some(parent => !nameToPerson.has(parent))) {\n        throw Error('Parent not found');\n    }\n    const father = convertPerson(nameToPerson.get(root.father), nameToPerson);\n    const mother = convertPerson(nameToPerson.get(root.mother), nameToPerson);\n    return { ...root, father, mother };\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.load = void 0;\nconst encryption_1 = require(\"./encryption\");\nconst tree_1 = require(\"./tree\");\nfunction personToRow(person, level, index) {\n    const fatherOrMother = level === 0 ? '' : index % 2 === 0 ? 'father' : 'mother';\n    const columns = [person.from || '??', person.born || '??', person.died || '??'];\n    const name = `<span class=\"name\">${person.name}</span>`;\n    return `<td class=${fatherOrMother}>${name}</td><td>${columns.join('</td><td>')}</td>`;\n}\nfunction generateLevelRow(level, depth) {\n    return `<td colspan=\"4\" class=\"generation\">Generation ${depth - level}</td>`;\n}\nfunction renderTree(data) {\n    const root = (0, tree_1.importTree)(data);\n    const depth = (0, tree_1.getDepth)(root);\n    Array(depth)\n        .fill(0)\n        .forEach((_, level) => {\n        const table = document.getElementById('main').children[0];\n        const levelRow = table.insertRow(-1);\n        levelRow.innerHTML = generateLevelRow(level, depth);\n        const people = (0, tree_1.getLevel)(root, level);\n        people.forEach((person, index) => {\n            const personRow = table.insertRow(-1);\n            personRow.innerHTML = personToRow(person, level, index);\n            personRow.id = nameToId(person.name);\n            personRow.children[0].children[0].onclick = () => highlight(root, personRow.id);\n        });\n    });\n}\nfunction highlight(root, subjectId) {\n    const person = (0, tree_1.getNode)(root, idToName(subjectId));\n    const parents = (0, tree_1.getParents)(person);\n    const children = (0, tree_1.getChildren)(root, person);\n    const highlightIds = [person, ...parents, ...children].map(person => nameToId(person.name));\n    const ids = [root, ...(0, tree_1.getParents)(root)].map(person => nameToId(person.name));\n    ids.forEach(id => document.getElementById(id)?.classList.remove('highlighted', 'selected'));\n    document.getElementById(subjectId)?.classList.add('selected');\n    highlightIds.forEach(id => document.getElementById(id)?.classList.add('highlighted'));\n}\nasync function fetchEncryptedData() {\n    const urlSearchParams = new URLSearchParams(window.location.search);\n    const isDemo = urlSearchParams.get('demo') === 'true';\n    const filename = isDemo ? 'demo-encrypted-data.txt' : 'encrypted-data.txt';\n    return fetch(filename).then(response => response.text());\n}\nasync function load() {\n    const encryptedData = await fetchEncryptedData();\n    const passwordBox = document.getElementById('password');\n    const data = await decrypt(encryptedData, passwordBox.value);\n    if (data) {\n        const peopleRaw = JSON.parse(data);\n        renderTree(peopleRaw);\n        document.getElementById('password-form').remove();\n        document.getElementById('main').classList.remove('hidden');\n    }\n    else {\n        passwordBox.value = '';\n        document.getElementById('password-message').classList.remove('hidden');\n    }\n}\nexports.load = load;\nasync function decrypt(encryptedData, password) {\n    try {\n        return await (0, encryption_1.decryptData)(encryptedData, password);\n    }\n    catch (e) {\n        console.error(e);\n        return undefined;\n    }\n}\nfunction nameToId(name) {\n    return name.replaceAll(' ', '-');\n}\nfunction idToName(name) {\n    return name.replaceAll('-', ' ');\n}\nexports.default = {\n    load,\n};\n"],"names":[],"sourceRoot":""}